{"name":"jDataView","tagline":"Extended DataView API. Anywhere.","body":"<a href=\"http://blog.vjeux.com/2011/javascript/jdataview-read-binary-file.html\">jDataView</a> - A unique way to work with a binary file in JavaScript.\r\n================================\r\n\r\njDataView provides a standard way to read and/or modify binary files in all the browsers. It follows the [DataView Specification](http://www.khronos.org/registry/webgl/doc/spec/TypedArray-spec.html#6) and even extends it for a more practical use.\r\n\r\nExplanation\r\n=========\r\n\r\nThere are three ways to read a binary file from the browser.\r\n\r\n* The first one is to download the file through XHR with [charset=x-user-defined](https://developer.mozilla.org/en/using_xmlhttprequest#Receiving_binary_data). You get the file as a **String**, convert it to byte **Array** and you have to rewrite all the decoding and encoding functions (getUint16, getFloat32, ...). All the browsers support this.\r\n\r\n* Then browsers that implemented **Canvas** also added **CanvasPixelArray** as part of **ImageData**. It is fast byte array that is created and used internally by `<canvas />` element for manipulating low-level image data. We can create such host element and use it as factory for our own instances of this array.\r\n\r\n* Then browsers that implemented **WebGL** added **ArrayBuffer**. It is a plain buffer that can be read with views called **TypedArrays** (Int32Array, Float64Array, ...). You can use them to decode the file but this is not very handy. It has big drawback, it can't read non-aligned data (but we can actually hack that).\r\n\r\n* A new revision of the specification added **DataViews**. It is a view around your buffer that can read/write arbitrary data types directly through functions: getUint32, getFloat64 ...\r\n\r\nAnd one way to read a binary file from the server.\r\n\r\n* **NodeJS Buffers**. They appeared in [Node 0.4.0](http://nodejs.org/docs/v0.4.0/api/buffers.html). [Node 0.5.0](http://nodejs.org/docs/v0.5.0/api/buffers.html) added a DataView-like API. And [Node 0.6.0](http://nodejs.org/docs/v0.6.0/api/buffers.html) changed the API naming convention.\r\n\r\njDataView provides the DataView API using the best available option between Arrays, TypedArrays, NodeJS Buffers and DataViews.\r\n\r\nAPI\r\n===\r\nSee the [Typed Array Specification](http://www.khronos.org/registry/typedarray/specs/latest/#8) for a detailed API.\r\n\r\nConstructor\r\n-----------------\r\n* new **jDataView**(buffer, offset, length, littleEndian = false)\r\n    * buffer can be either a binary String, any Array-like byte storage (Array, Uint8Array, Arguments, jQuery(Array), ...) or count of bytes if you want to operate on new empty buffer.\r\n    * littleEndian = false (Big Endian mode) is a default value for the view\r\n\r\nSpecification API\r\n-------------------------\r\nThe wrapper satisfies all the specification getters:\r\n\r\n* **getInt8**(byteOffset)\r\n* **getUint8**(byteOffset)\r\n* **getInt16**(byteOffset, littleEndian)\r\n* **getUint16**(byteOffset, littleEndian)\r\n* **getInt32**(byteOffset, littleEndian)\r\n* **getUint32**(byteOffset, littleEndian)\r\n* **getFloat32**(byteOffset, littleEndian)\r\n* **getFloat64**(byteOffset, littleEndian)\r\n\r\nAnd setters:\r\n\r\n* **setInt8**(byteOffset, value)\r\n* **setUint8**(byteOffset, value)\r\n* **setInt16**(byteOffset, value, littleEndian)\r\n* **setUint16**(byteOffset, value, littleEndian)\r\n* **setInt32**(byteOffset, value, littleEndian)\r\n* **setUint32**(byteOffset, value, littleEndian)\r\n* **setFloat32**(byteOffset, value, littleEndian)\r\n* **setFloat64**(byteOffset, value, littleEndian)\r\n\r\nExtended Specification\r\n---------------------------------\r\nAddition of a littleEndian argument to the constructor. Big Endian will be the default mode of getters if their littleEndian value is undefined.\r\n\r\n* **jDataView**(buffer, offset, length, littleEndian = false)\r\n\r\nThe byteOffset parameter is now optional. If you omit it, it will read right after the latest read offset. You can interact with the internal pointer with those two functions.\r\n\r\n* **seek**(byteOffset)\r\n    * Moves the internal pointer to the position\r\n* **tell**()\r\n    * Returns the current position\r\n* **skip**(byteLength)\r\n    * Skips given count of bytes\r\n* **slice**(start, end, forceCopy = false)\r\n    * Returns view (jDataView) on part of original one; may point to the same memory buffer or copy data into new one depending on forceCopy parameter.\r\n\r\nAlso, specification DataView setters require byteOffset as first argument, and passing \"undefined\" for sequential writes can be not very convenient.\r\nYou can use ```writeXXX``` methods instead, which will set values at current position automatically:\r\n\r\n* **writeInt8**(value)\r\n* **writeUint8**(value)\r\n* **writeInt16**(value, littleEndian)\r\n* **writeUint16**(value, littleEndian)\r\n* **writeInt32**(value, littleEndian)\r\n* **writeUint32**(value, littleEndian)\r\n* **writeFloat32**(value, littleEndian)\r\n* **writeFloat64**(value, littleEndian)\r\n\r\nAddition of Char, String and Bytes utilities.\r\nString operations globally support 'binary' (by default) and 'utf8' encodings; Char is always one-byte 'binary'.\r\n\r\n* **getChar**(byteOffset)\r\n* **setChar**(byteOffset, char)\r\n* **writeChar**(char)\r\n* **getString**(byteLength, byteOffset, encoding = 'binary')\r\n* **setString**(byteOffset, chars, encoding = 'binary')\r\n* **writeString**(chars, encoding = 'binary')\r\n* **getBytes**(length, byteOffset, littleEndian = true, toArray = false)\r\n* **setBytes**(byteOffset, bytes, littleEndian = true)\r\n* **writeBytes**(bytes, littleEndian = true)\r\n\r\nAddition of 64-bit signed and unsigned integer types.\r\n\r\n**IMPORTANT**: Those types behave like primitive numbers (you can manipulate with them using arithmetic operations, convert them to strings etc.)., **BUT** due to IEEE.754 limitations, there is precision loss for numbers outside the ±2^53 range, and that's why they also contain\r\n`lo` and `hi` fields for retrieving corresponding 32-bit unsigned parts. You can pass both primitive numbers (with the same restriction as above) or `jDataView.Uint64`/`jDataView.Int64` instances with `lo` and `hi` fields to writer functions as well.\r\n\r\n* **getInt64**(byteOffset, littleEndian)\r\n* **setInt64**(byteOffset, value, littleEndian)\r\n* **writeInt64**(value, littleEndian)\r\n* **getUint64**(byteOffset, littleEndian)\r\n* **setUint64**(byteOffset, value, littleEndian)\r\n* **writeUint64**(value, littleEndian)\r\n\r\nAddition of wrapBuffer and createBuffer, utilities to easily create buffers with the latest available storage type (Node.js Buffer, ArrayBuffer, CanvasPixelArray or simple Array).\r\n\r\n* **wrapBuffer**(string_or_bytes_or_byteCount)\r\n* **createBuffer**(byte1, byte2, ...)\r\n\r\nExample\r\n======\r\nFirst we need a file. Either you get it through XHR or use the createBuffer utility.\r\n\r\n```javascript\r\nvar file = jDataView.createBuffer(\r\n\t0x10, 0x01, 0x00, 0x00, // Int32 - 272\r\n\t0x90, 0xcf, 0x1b, 0x47, // Float32 - 39887.5625\r\n\t0, 0, 0, 0, 0, 0, 0, 0, // 8 blank bytes\r\n\t0x4d, 0x44, 0x32, 0x30, // String - MD20\r\n\t0x61                    // Char - a\r\n);\r\n```\r\n\r\nNow we use the DataView as defined in the specification, the only thing that changes is the j before jDataView.\r\n\r\n```javascript\r\nvar view = new jDataView(file);\r\nvar version = view.getInt32(0); // 272\r\nvar float = view.getFloat32(4); // 39887.5625\r\n```\r\n\r\nThe wrapper extends the specification to make the DataView easier to use.\r\n\r\n```javascript\r\nvar view = new jDataView(file);\r\n// A position counter is managed. Remove the argument to read right after the last read.\r\nversion = view.getInt32(); // 272\r\nfloat = view.getFloat32(); // 39887.5625\r\n\r\n// You can move around with tell(), seek() and skip()\r\nview.skip(8);\r\n\r\n// Two helpers: getChar and getString will make your life easier\r\nvar tag = view.getString(4); // MD20\r\nvar char = view.getChar(); // a\r\n```\r\n\r\nYou can use a <a href=\"http://blog.vjeux.com/2011/javascript/jquery-binary-ajax.html\">patched version of jQuery</a> that supports ArrayBuffer for AJAX.\r\n\r\n```javascript\r\n$.get(\r\n  'data.bin',\r\n  function (view) {\r\n    var tag = view.getString(4); // 'MD20'\r\n    var version = view.getUint32(); // 732\r\n  },\r\n  'dataview'\r\n);\r\n```\r\n\r\nChangelog\r\n========\r\n* **May 15 2013**\r\n  * jDataView got [own account](https://github.com/jDataView)! More projects and demos coming soon.\r\n* **May 30 2013**:\r\n  * [RReverser](https://github.com/rreverser) added support for UTF-8 strings\r\n  * Added support for 64-bit signed and unsigned integers (with precision loss outside the ±2^53 range when using primitive JS numbers due to IEEE.754 restrictions)\r\n  * Added support for CanvasPixelArray as fast byte array for browsers that don't support Typed Arrays yet (like IE9)\r\n  * Refactored code.\r\n  * Added ability to test library on all the engines that are supported on current platform at once.\r\n  * Added JSHint configuration according to project code guidelines and implemented corresponding QUnit test.\r\n* **April 8 2013**:\r\n  * [mmthomas](http://blog.coolmuse.com/) implemented support for denormalized float values in setters\r\n* **March 16 2013**:\r\n  * [RReverser](https://github.com/rreverser) added support for setters in all supported implementations!\r\n  * Performance improvements changing lower level constructs and type of inner buffers\r\n  * Addition of [gs]etBytes, write*, wrapBuffer and slice helpers\r\n  * Added support for any Array-like byte storage as input (Array, Uint8Array, Arguments, jQuery(Array), ...)\r\n  * Added ability to create empty buffer (and operate on it) by passing count of bytes to wrapBuffer.\r\n* **June 30 2012**: Thanks to [Mithgol](https://github.com/Mithgol) for the changes!\r\n  * Changed default to big endian from little endian to be compatible with DataView specification\r\n  * Dropped support for NodeJS < 0.5.5, it was buggy anyway\r\n  * Fixed an issue where ArrayBuffer would not work on NodeJS\r\n  * Moved the compatibility checks outside of the read functions for hopefully better performance\r\n* **December 22 2011**: Added IE6-9 support by [scintill](https://github.com/scintill)\r\n* **November 30 2011**:\r\n  * Added NodeJS Buffer support + NPM Package.\r\n  * Added support for NaN and Infinity in the float shim.\r\n  * Added ```buffer```, ```byteLength``` and ```byteOffset``` attributes.\r\n  * Fixed bugs using non zero ```byteOffset``` and added more bound checks.\r\n* **September 21 2011**: Added a missing ```littleEndian``` argument on getInt16.\r\n* **April 28 2011**: Seeking to the end of file no longer throws an error.\r\n* **April 26 2011**: Fixed a bug with extremely large unsigned 32bit being considered as signed. ([Solution](http://stackoverflow.com/questions/1240408/reading-bytes-from-a-javascript-string/2954435#2954435)). \r\n* **April 8 2011**: Added littleEndian argument on the constructor. Opera 11.50 does not fully implement DataView, improved check.\r\n\r\nDemos\r\n==== \r\n\r\n* A <a href=\"http://jdataview.github.io/jDataView/untar/\">simple tar viewer</a>. It is a \"Hello World\" demo of how easy it is to use the library.\r\n\r\n* <a href=\"http://rreverser.com/dev/bmp/\">BMP viewer</a> with ability to load files by URL or using File API, parsing them using library and rendering with Canvas (no `<img />` elements at all).\r\n\r\n* A <a href=\"http://www.visual-experiments.com/2011/04/05/photosynth-webgl-viewer/\">PhotoSynth WebGL Viewer</a> by Visual Experiments. It uses jDataView to read the binary file and then WebGL to display it.\r\n<a href=\"http://www.visual-experiments.com/2011/04/05/photosynth-webgl-viewer/\"><img src=\"http://i.imgur.com/HRHXo.jpg\"/></a>\r\n\r\nPlease tell us if you made something with jDataView :)\r\n\r\nLicence: [Do What The Fuck You Want To Public License](http://sam.zoy.org/wtfpl/)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}